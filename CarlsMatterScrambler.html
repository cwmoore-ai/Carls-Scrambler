<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carl's Physics Scrambler</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <style>
        /* --- CSS START --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Nicer Gradient Background */
            background: linear-gradient(135deg, #1f2833, #45a29e 60%, #66fcf1);
            color: #c5c6c7; /* Light grey text */
            margin: 0;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
            overflow-x: hidden;
        }

        /* Background Text Styling */
        body::before {
            content: "Carl's Physics Scrambler";
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2rem, 11vw, 7rem); /* Slightly smaller max */
            font-weight: bold;
            color: rgba(255, 255, 255, 0.08); /* Even subtler white */
            z-index: -1;
            text-align: center;
            pointer-events: none;
            white-space: nowrap;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
        }

        h1 {
            margin-bottom: 15px; /* Reduced margin */
            color: #66fcf1; /* Teal Accent */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
            z-index: 1;
            text-align: center;
            font-size: clamp(1.8rem, 5vw, 2.8rem); /* Responsive Title */
        }

        .simulation-container {
            position: relative;
            margin-bottom: 20px;
            border: 5px solid #1f2833; /* Dark border */
            border-radius: 8px; /* Rounded corners */
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.4);
            /* Inner shadow for depth */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 5px 25px rgba(0, 0, 0, 0.4);
            background-color: #0b0c10; /* Very dark canvas background */
            overflow: hidden;
            max-width: 95vw; /* Allow slightly wider */
            z-index: 1;
             /* Aspect Ratio (optional, helps maintain shape) */
             /* aspect-ratio: 800 / 650; /* Adjusted for slightly taller canvas */
        }

        #simulationCanvas {
            display: block;
            /* Ensure background color is set via JS options for Matter.js */
        }

        .controls {
            background-color: rgba(11, 12, 16, 0.88); /* Darker controls bg */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); /* Slightly narrower min */
            gap: 18px; /* Increased gap */
            width: 90%; /* Wider controls */
            max-width: 1000px;
            margin-bottom: 20px;
            z-index: 1;
            border: 1px solid rgba(69, 162, 158, 0.3); /* Subtle border */
        }

        .controls h2 {
            grid-column: 1 / -1;
            text-align: center;
            margin-top: 0;
            margin-bottom: 15px;
            color: #45a29e; /* Teal accent */
            font-weight: 600;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            background-color: rgba(31, 40, 51, 0.6); /* Control group background */
            padding: 12px;
            border-radius: 5px;
        }

        .control-group label {
            margin-bottom: 8px;
            font-weight: 500; /* Normal weight */
            color: #c5c6c7;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            cursor: pointer;
            margin-bottom: 5px;
        }

        .control-group span {
            text-align: right;
            font-size: 0.9em;
            color: #66fcf1; /* Teal value */
            font-weight: bold;
            min-height: 1.1em;
        }

        .button-group {
            grid-column: 1 / -1;
            display: flex;
            justify-content: center;
            gap: 25px; /* More space */
            margin-top: 15px;
        }

        button {
            padding: 12px 28px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            transition: all 0.3s ease; /* Smoother transition */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            color: #0b0c10; /* Dark text on buttons */
        }

        #addBallsButton {
            background-color: #66fcf1; /* Teal */
        }

        #addBallsButton:hover {
            background-color: #45a29e;
             box-shadow: 0 4px 10px rgba(102, 252, 241, 0.4); /* Glow effect */
             transform: translateY(-2px);
        }

        #clearBallsButton {
            background-color: #c5c6c7; /* Light grey */
        }

        #clearBallsButton:hover {
            background-color: #8f9091;
            box-shadow: 0 4px 8px rgba(197, 198, 199, 0.3);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0px) scale(0.98); /* Press effect */
        }

        /* Slider styling */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            height: 7px; /* Slightly thinner */
            background: #1f2833; /* Dark track */
            border-radius: 5px;
            outline: none;
            transition: background 0.3s ease;
        }
         input[type=range]:hover {
              background: #2a3a4a;
         }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; /* Smaller thumb */
            height: 18px;
            background: #66fcf1; /* Teal thumb */
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #1f2833; /* Border matches track */
            transition: background 0.3s ease;
        }
         input[type=range]:active::-webkit-slider-thumb {
             background: #45a29e; /* Darker teal on press */
         }

        input[type=range]::-moz-range-thumb {
             width: 18px;
             height: 18px;
             background: #66fcf1;
             border-radius: 50%;
             cursor: pointer;
             border: 2px solid #1f2833;
             transition: background 0.3s ease;
        }
         input[type=range]:active::-moz-range-thumb {
             background: #45a29e;
         }

        /* --- CSS END --- */
    </style>
</head>
<body>
    <h1>Carl's Physics Scrambler</h1>

    <div class="simulation-container">
        <canvas id="simulationCanvas"></canvas>
    </div>

    <div class="controls">
        <h2>Controls</h2>

        <div class="control-group">
            <label for="ballCountSlider">Balls to Add (per click):</label>
            <input type="range" id="ballCountSlider" min="1" max="50" value="10">
            <span id="ballCountValue">10</span>
        </div>

        <div class="control-group">
            <label for="ballSizeSlider">Ball Size:</label>
            <input type="range" id="ballSizeSlider" min="5" max="30" value="15">
            <span id="ballSizeValue">15</span>px radius
        </div>

        <div class="control-group">
            <label for="gravitySlider">Gravity (Y):</label>
            <input type="range" id="gravitySlider" min="0" max="200" value="100">
            <span id="gravityValue">1.0</span>
        </div>

        <div class="control-group">
            <label for="tiltSlider">Scrambler Tilt (X Gravity):</label>
            <input type="range" id="tiltSlider" min="-100" max="100" value="0">
            <span id="tiltValue">0.0</span>
        </div>

        <div class="button-group">
             <button id="addBallsButton">Drop Balls!</button>
             <button id="clearBallsButton">Clear Balls</button>
        </div>
    </div>

    <script>
        // --- JAVASCRIPT START ---
        document.addEventListener('DOMContentLoaded', () => {
            const Engine = Matter.Engine,
                  Render = Matter.Render,
                  Runner = Matter.Runner,
                  Bodies = Matter.Bodies,
                  Composite = Matter.Composite,
                  World = Matter.World,
                  Events = Matter.Events,
                  Body = Matter.Body;

            const canvas = document.getElementById('simulationCanvas');
            const simulationContainer = document.querySelector('.simulation-container');
            const ballCountSlider = document.getElementById('ballCountSlider');
            const ballCountValue = document.getElementById('ballCountValue');
            const ballSizeSlider = document.getElementById('ballSizeSlider');
            const ballSizeValue = document.getElementById('ballSizeValue');
            const gravitySlider = document.getElementById('gravitySlider');
            const gravityValue = document.getElementById('gravityValue');
            const tiltSlider = document.getElementById('tiltSlider');
            const tiltValue = document.getElementById('tiltValue');
            const addBallsButton = document.getElementById('addBallsButton');
            const clearBallsButton = document.getElementById('clearBallsButton');

            let engine;
            let render;
            let runner;
            const canvasWidth = 800; // Base width
            const canvasHeight = 650; // Increased height slightly for more scrambler space
            const wallThickness = 60; // Thicker walls

            // --- NEW --- References for rotating elements
            let rotatingBars = [];
            let rotationSpeed = 0.002; // Slow rotation speed

            // --- Initialization ---
            function initSimulation() {
                engine = Engine.create({
                     // Enable sleeping to improve performance for resting bodies
                     enableSleeping: true
                });
                engine.world.gravity.y = parseFloat(gravityValue.textContent);
                engine.world.gravity.x = parseFloat(tiltValue.textContent);

                const containerWidth = simulationContainer.clientWidth;
                const scale = Math.min(1, containerWidth / canvasWidth);
                const effectiveWidth = canvasWidth * scale;
                const effectiveHeight = canvasHeight * scale;

                render = Render.create({
                    element: simulationContainer,
                    canvas: canvas,
                    engine: engine,
                    options: {
                        width: effectiveWidth,
                        height: effectiveHeight,
                        wireframes: false,
                        background: '#0b0c10', // Match container bg
                         // Enhance rendering quality slightly
                        pixelRatio: window.devicePixelRatio > 1 ? 1.5 : 1, // Use higher pixel ratio cautiously
                        showSleeping: false // Don't show sleeping bodies differently
                    }
                });

                canvas.style.width = `${effectiveWidth}px`;
                canvas.style.height = `${effectiveHeight}px`;

                runner = Runner.create();

                 // --- NEW --- Event listener for rotation before each engine update
                 Events.on(engine, 'beforeUpdate', rotateElements);

                setupWorld(effectiveWidth, effectiveHeight);

                Render.run(render);
                Runner.run(runner, engine);

                updateSliderValue(ballCountSlider, ballCountValue);
                updateSliderValue(ballSizeSlider, ballSizeValue, 'px radius');
                updateSliderValue(gravitySlider, gravityValue, '', v => (v / 100).toFixed(1));
                updateSliderValue(tiltSlider, tiltValue, '', v => (v / 100).toFixed(1));
            }

            // --- World Setup (HEAVILY MODIFIED) ---
            function setupWorld(width, height) {
                 World.clear(engine.world, false); // Clear previous bodies
                 rotatingBars = []; // Clear references to old rotating bars

                 const wallColor = '#1F2833'; // Dark wall color matching theme
                 const wallOptions = {
                     isStatic: true,
                     render: { fillStyle: wallColor },
                     restitution: 0.1, // Low restitution for walls
                     friction: 0.5
                 };

                 // Ground slightly lower to ensure balls rest fully below view if needed
                 const ground = Bodies.rectangle(width / 2, height + wallThickness / 2 - 10, width + wallThickness, wallThickness, wallOptions);
                 const leftWall = Bodies.rectangle(-wallThickness / 2, height / 2, wallThickness, height + wallThickness, wallOptions);
                 const rightWall = Bodies.rectangle(width + wallThickness / 2, height / 2, wallThickness, height + wallThickness, wallOptions);
                 // Add a ceiling to prevent balls escaping upwards during high bounce/tilt
                 const ceiling = Bodies.rectangle(width / 2, -wallThickness / 2, width + wallThickness, wallThickness, wallOptions);


                 // --- Enhanced Scrambler Elements ---
                 const scramblerElements = [];
                 const pegBaseRadius = 8; // Slightly smaller base pegs
                 const pegRows = 10; // More rows
                 const pegCols = 12; // More columns
                 const pegHSpacing = width / (pegCols + 1); // Horizontal spacing based on width
                 const pegVSpacing = (height * 0.75) / (pegRows + 1); // Vertical spacing over 75% height
                 const startY = height * 0.1; // Start pegs higher up

                 const colorPalette = ['#66fcf1', '#45a29e', '#c5c6c7', '#ffffff']; // Teal, Dark Teal, Grey, White

                 for (let row = 0; row < pegRows; row++) {
                     const colsInRow = pegCols + (row % 2 === 0 ? 0 : -1); // Offset alternate rows
                     const rowStartX = pegHSpacing + (row % 2 === 0 ? 0 : pegHSpacing / 2);

                     for (let col = 0; col < colsInRow ; col++) {
                         const x = rowStartX + col * pegHSpacing;
                         const y = startY + row * pegVSpacing;

                         // Introduce variety
                         const pegType = Math.random();
                         let element;

                         if (pegType < 0.85) { // 85% chance of being a circle peg
                             const radius = pegBaseRadius * (0.8 + Math.random() * 0.4); // Vary size slightly (80% to 120%)
                             const restitution = 0.3 + Math.random() * 0.3; // Vary bounciness (0.3 to 0.6)
                             const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];

                             element = Bodies.circle(x, y, radius, {
                                 isStatic: true,
                                 restitution: restitution,
                                 friction: 0.1,
                                 render: {
                                     fillStyle: color,
                                     strokeStyle: '#0B0C10', // Outline matching background
                                     lineWidth: 1
                                 }
                             });
                         } else if (pegType < 0.95) { // 10% chance of being a small static box
                             const size = pegBaseRadius * 2 * (0.9 + Math.random() * 0.2);
                              const angle = (Math.random() - 0.5) * Math.PI * 0.2; // Slight random angle
                              element = Bodies.rectangle(x, y, size, size, {
                                   isStatic: true,
                                   angle: angle,
                                   restitution: 0.2,
                                   friction: 0.2,
                                   render: {
                                        fillStyle: colorPalette[2], // Grey color
                                        strokeStyle: '#0B0C10',
                                        lineWidth: 1
                                   }
                              });
                         }
                         // else { 5% chance of empty space }

                         if (element && x > radius && x < width - radius && y > radius && y < height - radius * 2) { // Basic boundary check
                             scramblerElements.push(element);
                         }
                     }
                 }

                 // --- Add Larger Obstacles and Rotating Bars ---
                 const largeObstacles = [];

                 // Example: A central funnel shape (two angled static bars)
                 const funnelWidth = width * 0.2;
                 const funnelHeight = height * 0.1;
                 const funnelY = height * 0.5;
                 largeObstacles.push(Bodies.rectangle(width * 0.4, funnelY, funnelWidth, 15, {
                     isStatic: true, angle: -0.4, render: { fillStyle: colorPalette[1] } // Dark Teal
                 }));
                  largeObstacles.push(Bodies.rectangle(width * 0.6, funnelY, funnelWidth, 15, {
                     isStatic: true, angle: 0.4, render: { fillStyle: colorPalette[1] }
                 }));

                 // Example: Rotating bars
                 const barWidth = width * 0.18;
                 const barHeight = 10;
                 const barY1 = height * 0.3;
                 const barY2 = height * 0.7;

                 const rotatingBar1 = Bodies.rectangle(width * 0.25, barY1, barWidth, barHeight, {
                      isStatic: true, angle: Math.random() * Math.PI, // Random start angle
                      render: { fillStyle: colorPalette[0] } // Bright Teal
                 });
                  const rotatingBar2 = Bodies.rectangle(width * 0.75, barY2, barWidth, barHeight, {
                      isStatic: true, angle: Math.random() * Math.PI,
                      render: { fillStyle: colorPalette[0] }
                 });

                 rotatingBars.push(rotatingBar1); // Add to list for rotation update
                 rotatingBars.push(rotatingBar2);
                 largeObstacles.push(rotatingBar1);
                 largeObstacles.push(rotatingBar2);


                 // Add all elements to the world
                 World.add(engine.world, [
                     ground, leftWall, rightWall, ceiling,
                     ...scramblerElements,
                     ...largeObstacles
                 ]);
             }

            // --- NEW --- Function to rotate specific elements ---
            function rotateElements() {
                const currentRotationSpeed = rotationSpeed * (Math.random() * 0.5 + 0.75); // Slight speed variation
                 rotatingBars.forEach(bar => {
                     // Use Body.setAngle for static bodies
                     Body.setAngle(bar, bar.angle + currentRotationSpeed);
                 });
            }

             // --- Peg/Ball Color Helpers (Consolidated) ---
             function getRandomElementColor() {
                // Generate vibrant, slightly desaturated colors suitable for theme
                const hue = 180 + Math.random() * 60; // Hues around Teal/Cyan/Blue
                const saturation = 60 + Math.random() * 30; // 60% to 90%
                const lightness = 65 + Math.random() * 15;  // 65% to 80% (brighter)
                return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
             }

            // --- Ball Creation ---
            function addBalls() {
                const count = parseInt(ballCountSlider.value);
                const radius = parseInt(ballSizeSlider.value);
                const width = render.options.width;

                for (let i = 0; i < count; i++) {
                    const x = width * 0.5 + (Math.random() - 0.5) * width * 0.7; // Wider spawn area
                    const y = -radius * 2 - Math.random() * 30;

                    const ball = Bodies.circle(x, y, radius, {
                        restitution: 0.5 + Math.random() * 0.2, // Slightly variable bounciness (0.5-0.7)
                        friction: 0.02,
                        frictionAir: 0.001, // Slight air friction
                        density: 0.0015, // Slightly denser balls
                        render: {
                            fillStyle: getRandomElementColor(),
                            strokeStyle: '#1f2833', // Dark outline
                            lineWidth: 1
                        },
                        // Allow balls to sleep when resting
                        sleepThreshold: 60
                    });
                    World.add(engine.world, ball);
                }
            }

            // --- Clear Balls ---
            function clearBalls() {
                const allBodies = Composite.allBodies(engine.world);
                const ballsToRemove = allBodies.filter(body => !body.isStatic);
                if (ballsToRemove.length > 0) {
                     World.remove(engine.world, ballsToRemove);
                }
            }

            // --- Control Event Listeners ---
            function updateSliderValue(slider, displayElement, unit = '', formatter = null) {
                 let value = slider.value;
                 displayElement.textContent = formatter ? formatter(value) : value;
                 if (unit) {
                     displayElement.textContent += unit;
                 }
            }

            ballCountSlider.addEventListener('input', () => updateSliderValue(ballCountSlider, ballCountValue));
            ballSizeSlider.addEventListener('input', () => updateSliderValue(ballSizeSlider, ballSizeValue, 'px radius'));

            gravitySlider.addEventListener('input', () => {
                const gravityY = parseFloat(gravitySlider.value) / 100;
                if (engine) engine.world.gravity.y = gravityY;
                updateSliderValue(gravitySlider, gravityValue, '', v => (v / 100).toFixed(1));
            });

            tiltSlider.addEventListener('input', () => {
                const gravityX = parseFloat(tiltSlider.value) / 100;
                if (engine) engine.world.gravity.x = gravityX;
                 updateSliderValue(tiltSlider, tiltValue, '', v => (v / 100).toFixed(1));
            });

            addBallsButton.addEventListener('click', addBalls);
            clearBallsButton.addEventListener('click', clearBalls);

             // --- Resize Handling ---
             let resizeTimeout;
             function handleResize() {
                  if (!render || !engine) return;
                  console.log("Resizing simulation...");
                  Render.stop(render);
                  Runner.stop(runner);
                  Events.off(engine, 'beforeUpdate', rotateElements); // Important: Remove old listener

                  const containerWidth = simulationContainer.clientWidth;
                  const scale = Math.min(1, containerWidth / canvasWidth);
                  const effectiveWidth = canvasWidth * scale;
                  const effectiveHeight = canvasHeight * scale;

                  render.options.width = effectiveWidth;
                  render.options.height = effectiveHeight;
                  render.canvas.width = effectiveWidth;
                  render.canvas.height = effectiveHeight;
                  render.canvas.style.width = `${effectiveWidth}px`;
                  render.canvas.style.height = `${effectiveHeight}px`;
                  render.bounds.max.x = effectiveWidth;
                  render.bounds.max.y = effectiveHeight;

                  const staticBodies = Composite.allBodies(engine.world).filter(body => body.isStatic);
                  if (staticBodies.length > 0) {
                      World.remove(engine.world, staticBodies);
                  }
                   rotatingBars = []; // Clear references before setupWorld recreates them

                  // Re-add the listener *after* the engine instance exists
                  Events.on(engine, 'beforeUpdate', rotateElements);

                  setupWorld(effectiveWidth, effectiveHeight);

                  Render.run(render);
                  Runner.run(runner, engine);
                  console.log("Simulation updated after resize.");
             }

             window.addEventListener('resize', () => {
                 clearTimeout(resizeTimeout);
                 resizeTimeout = setTimeout(handleResize, 250);
             });

            // --- Start ---
            initSimulation();

        }); // End DOMContentLoaded
        // --- JAVASCRIPT END ---
    </script>
</body>
</html>